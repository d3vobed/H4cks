document.getElementById('fetchBalance').addEventListener('click', function() {
    var input = document.getElementById('ethAddress').value;
    var addresses = input.split('+&').map(address => address.trim()); // Split input by "+&" and trim whitespace

    if (addresses.length === 1) {
        // If only one address is provided, get balance for that address
        getBalance(addresses[0]).then(result => {
            // Display balance for the single address
            var resultData = { address: addresses[0], balance: result };
            document.getElementById('result').innerText = JSON.stringify(resultData, null, 2);
        });
    } else if (addresses.length === 3) {
        // If exactly three addresses are provided, get balances, tokens, and flag
        getWalletInfo(addresses);
    } else {
        // If incorrect number of addresses are provided, show error message
        var errorData = { error: 'Denied request. Only one or three addresses allowed.' };
        document.getElementById('result').innerText = JSON.stringify(errorData, null, 2);
    }
});

function getWalletInfo(addresses) {
    var walletInfo = {
        wallet: [],
        token: [],
        flag: ""
    };

    // Fetch balance and tokens for each address
    addresses.forEach(function(address) {
        getBalance(address).then(balance => {
            // Introduce vulnerability: Log the balance to console
            console.log('Balance for ' + address + ': ' + balance);

            // Store wallet balance
            walletInfo.wallet.push({ address: address, balance: balance });

            // Simulate tokens for demonstration purposes
            var tokens = Math.floor(Math.random() * 1000); // Generate random number of tokens
            walletInfo.token.push({ address: address, tokens: tokens });

            // Check if all addresses have been processed
            if (walletInfo.wallet.length === 3) {
                // Introduce obfuscation: Encode the flag
                walletInfo.flag = encodeFlag("flag{aiit_h3r3's_da_k2ys_0xd3adbeaf}");
                // Display walletInfo as JSON
                document.getElementById('result').innerText = JSON.stringify(walletInfo, null, 2);
            }
        });
    });
}

function getBalance(address) {
    var myHeaders = new Headers();
    myHeaders.append("Content-Type", "application/json");

    var raw = JSON.stringify({
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1,
        "jsonrpc": "2.0"
    });

    var requestOptions = {
        method: 'POST',
        headers: myHeaders,
        body: raw,
        redirect: 'follow'
    };

    return fetch("https://quick-quick-model.quiknode.pro/4347eba47aae2cfd9c73ccd76fc8a25cd2bb62bc/", requestOptions)
        .then(response => response.json())
        .then(data => {
            if (data.result) {
                var balanceInEther = parseInt(data.result, 16) / 1e18;
                var balanceFixed = balanceInEther.toFixed(2);
                return balanceFixed;
            } else {
                return 'Error fetching balance';
            }
        })
        .catch(error => {
            return 'Error fetching balance';
        });
}

// Simple encryption function to encode the flag
function encodeFlag(flag) {
    var encodedFlag = "";
    for (var i = 0; i < flag.length; i++) {
        var charCode = flag.charCodeAt(i);
        encodedFlag += String.fromCharCode(charCode + 1); // Shift each character code by 1
    }
    return encodedFlag;
}
